call pathogen#infect()

set nocompatible                  " Disable vi compatibility (must come first)

set encoding=utf-8                " Default to UTF8, don't use value from $LANG
set nobomb                        " And don't add a BOM, assume UTF8 everywhere

set nomodeline                    " No modelines (potential for security issues)

set nofixeol                      " Disable fixeol by default, use .editorconfig

set cursorline                    " Highlight the cursor line

set ttyfast                       " Assume a fast terminal connection

runtime macros/matchit.vim        " Load the matchit plugin

syntax enable                     " Turn on syntax highlighting
filetype plugin indent on         " Turn on file type detection and indentation

set autoindent                    " Auto-indent if no file type specific indent

set expandtab sts=2 sw=2          " Default to two-space indent, no tabs

set showcmd                       " Show incomplete commands as you type

set backspace=indent,eol,start    " Intuitive backspacing

set hidden                        " Allow hidden buffers with unsaved changes

set wildmenu                      " Enhanced command line completion
set wildmode=list:longest         " Complete files like a shell

set ignorecase                    " Ignore case when searching
set smartcase                     " Except when search contains capital letters
if exists("&tagcase")
  set tagcase=followscs           " Update tag search to to the same
endif
set infercase                     " And infer case when doing keyword completion

if exists("&fileignorecase")
  set fileignorecase              " Make file name completion case-insensitive
endif

set number                        " Show line numbers in left margin
set ruler                         " Show cursor position in default status line

set incsearch                     " Highlight and move to match as you type
au CmdlineEnter /,\?,: :set hls   " Highlight all matches while searching
au CmdlineLeave /,\?,: :set nohls " Hide all matches when search completed

set nowrap                        " Turn off line wrapping by default
set scrolloff=1                   " Show context when scrolling vertically

set sidescroll=1                  " Scroll hoizontally one column at a time
set sidescrolloff=2               " Show context when scrolling horizontally

set title                         " Set the terminal's title

set belloff=all                   " No beeping, ever, not even visual

set confirm                       " Allow dialog to confirm an action
set autoread                      " Skip confirm for file changed outside vim
set writeany                      " Allow writing of any file without confirm

set writebackup                   " Create backups before overwriting files
set nobackup                      " But don't retain backups after writing
set directory=$HOME/.vim/tmp//    " Keep swap files in one location
set backupdir=$HOME/.vim/tmp//    " And backups in the same place

set laststatus=2                  " Show the status line all the time

set splitright                    " Open vertical splits to the right
set splitbelow                    " Open horizontal splits below

set t_Co=256                      " Assume a 256 color terminal, ignore $TERM

if $TERM_PROGRAM =~# 'iTerm'
  colorscheme solarized           " Match dark iTerm color scheme locally
elseif has('gui_running')
  colorscheme PaperColor          " High contrast light bg colors for gui
elseif $SSH_CLIENT != ''
  colorscheme jellybeans          " Distinct color scheme for ssh sessions
endif

if has('balloon_eval')
  set noballooneval               " Disable slow and annoying tooltips
endif

if exists("&synmaxcol")
  set synmaxcol=200               " Disable syntax highlighting on very long lines
endif

set nofoldenable                  " Open all folds by default
set foldlevel=99                  " Don't open/close all folds at same indent
set foldlevelstart=99             " Reset fold level when opening new files
set foldmethod=indent             " Keep it simple stupid, just fold on indent
set foldignore=''                 " Don't ignore # when folding on indent

set updatetime=1000               " Default updatetime for gitgutter and friends

set shortmess+=c                  " Don't send ins-completion-menu messages
set shortmess+=F                  " Don't show file info messages, use statusline

" Sign column configuration - condition copied from coc.nvim readme
if has("nvim-0.5.0") || has("patch-8.1.1564")
  " Merge sign column and number column if supported
  set signcolumn=number
else
  " Otherwise at least use same colours as number column
  hi! link SignColumn LineNr
endif

" Suffixes that can be ignored when completing file names
set suffixes=.bak,~,.swp,.o,.info,.aux,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc

" Patterns that should be ignored when expanding wildcards
set wildignore=*~,*.o,*.aux,*.dvi,*.pdf,*.gif,*.jpg,*.png,*.pyc,.DS_Store,*.egg*,.git,__pycache__

" Custom status line, show relative file path and file type
set statusline=%<%.99{expand('%:~:.')}\ \%h%w%m%r%{get(g:,'ZoomWin_statusline','')}\ %=\ %{&ft}\ %l\:\%-c\ %P

" Store windows, tabs, current directory, and buffer info in sessions
" Exclude blank to avoid issues with nofile & quickfix windows (e.g.
" NERDTree, Tagbar, Ack), which are not well supported by vim sessions
set sessionoptions=buffers,curdir,tabpages,winsize,winpos,resize

" save upper case globals with viminfo - sessionman uses g:LAST_SESSION
set viminfo^=!

" set list mode characters used to display whitespace, toggle with <leader>tw
" note: only use basic latin and latin 1 supplement unicode characters to
" avoid missing glyphs, see https://github.com/tpope/vim-sensible/issues/57
set listchars=tab:»·,nbsp:¤,trail:·,lead:·,multispace:·

" Ins mode completion options - complete without menu if just one match,
" only complete to longest common match, don't use preview scratch window
set completeopt=menuone,longest

" Include dictionary words in completion menu when spellcheck is enabled
set complete+=kspell

" Disable completing keywords in included files, can make completion slow
set complete-=i

" When joining lines, use one space rather than two after punctuation
set nojoinspaces

"Delete comment character when joining commented lines
set formatoptions+=j

" If using grep, at least ignore binaries and exclude some paths
set grepprg="grep -n -I --exclude=tags --exclude-dir=.git $* /dev/null"

" Keep timeoutlen short enough to make WhichKey menu appear promptly, but not
" so short that it makes it almost impossible to complete multi-key mappings
set timeoutlen=1000

" Set ttimeoutlen, primarily to make it faster to exit popup windows
set ttimeoutlen=100

" Reuse existing windows when opening files from the quickfix window
set switchbuf=useopen
if has("patch-8.1.2315")
  set switchbuf+=uselast
endif

" Minimalist fold text, just show first line, no line count etc.
set foldtext=getline(v:foldstart)

" Override fillchars to avoid filling folded line with dashes
set fillchars=fold:\ ,vert:\|,eob:~

" map leader to comma so it's in the same position on all keyboards
let mapleader = ","

" use normal rather than hanging indent for multiline ruby assignment, i.e.
" let x = if foo    --NOT--    let x = if foo
"   bar                                  bar
" end                                  end
let g:ruby_indent_assignment_style = 'variable'

" Disable vim-visual-multi mappings, except CTRL-n (select words)
let g:VM_default_mappings = 0

" Disable indentLine plugin by default, toggle with <leader>ti
let g:indentLine_enabled = 0

" Use same highlighting for indent lines as used for whitespace listchars
let g:indentLine_defaultGroup = 'SpecialKey'

" Disable conceal for json and markdown, indentLine sets conceallevel to 2, so
" enabling it will conceal some characters in filetypes with built in support
" (I find this acceptable, I don't use conceal, I prefer some kind of preview)
let g:vim_json_conceal=0
let g:markdown_syntax_conceal=0

" Tell vim-qf to enable ack.vim style mappings in quickfix window
let g:qf_mapping_ack_style = 1

" Tell vim-qf to use a fixed window size (default 10)
let g:qf_auto_resize = 0

" Tell vim-qf not to mess with loclist positioning (1 qflist, many loclists)
let g:qf_loclist_window_bottom = 0

" Tell QFEnter to skip some filetypes when choosing window to open
" Note: plugin required because vim only reuses normal buffers when opening
" files from quickfix windows, which does not work well with bufexplorer etc.
let g:qfenter_exclude_filetypes = ['nerdtree', 'tagbar', 'scratch']

" Tell QFEnter to move to next usable window rather than simply echo an error
" when attempting to open a file in a window matching an excluded filetype
let g:qfenter_excluded_action = 'next'

" Open WhichKey menu for leader mappings after timeoutlen (500ms)
nnoremap <silent> , :WhichKey ','<CR>

" Define dictionary with prefix names for leader mappings
call which_key#register(',', "g:which_key_map")
let g:which_key_map =  {}
let g:which_key_map.f = { 'name' : '+fzfind' }
let g:which_key_map.t = { 'name' : '+toggle' }
let g:which_key_map.w = { 'name' : '+window' }

" Disable caching of WhichKey menus - allow for buffer local mappings
let g:which_key_run_map_on_popup = 1

" Run native command when mapping not defined (required for WhichKey 'g')
let g:which_key_fallback_to_native_key = 1

" Disable default bullets.vim mappings, clashes with other mappings
let g:bullets_set_mappings = 0

" Add custom bullets mappings that don't clash with other mappings
function! InsertNewBullet()
  InsertNewBullet
  return ''
endfunction
autocmd FileType markdown,text,gitcommit
  \ inoremap <buffer><expr> <cr> (pumvisible() ? '<C-y>' : '<C-]><C-R>=InsertNewBullet()<cr>')|
  \ nnoremap <buffer> o :InsertNewBullet<cr>|
  \ nnoremap cx :ToggleCheckbox<cr>

" don't automatically save session on exit in non-gui vim
let sessionman_save_on_exit=0

" minimalist sessions list, hide mappings help
let sessionman_minimal_ui = 1

" disable rails plugin on vim enter, slow when used with vim-bundler
" also results in some garbage written to screen, seems a vim issue
" see https://github.com/tpope/vim-rails/issues/579 for some info
let g:rails_vim_enter = 0

" disable projectionist on vim enter, also causes garbage to be written
" to screen, also see https://github.com/tpope/vim-rails/issues/579
let g:projectionist_vim_enter = 0

" Don't add the recent files menu from MRU plugin
let MRU_Add_Menu = 0

" Use the current window to load the list of MRU files
let MRU_Use_Current_Window = 1

" Don't add git commits, private or tmp files to MRU files
let MRU_Exclude_Files = '\.git*\|^/\(private\|tmp\|var\)/.*'

" Don't fuzzy match when filtering MRU files, orders on match score
let MRU_FuzzyMatch = 0

" Tell tagbar to stop enabling ballooneval
let g:tagbar_show_balloon = 0

" Don't auto-generate tags files in every source code repo
let g:gutentags_generate_on_new = 0
let g:gutentags_generate_on_missing = 0

" But do generate when I write a file, for now anyway
" Note: Consider disabling gutentags entirely by default
let g:gutentags_generate_on_write = 1

" Assume a POSIX-compatible shell when shebang specifies /bin/sh, otherwise
" highlighting is system dependent as the sh syntax file resolves symlinks
let g:is_posix = 1

" Tell netrw to also stop enabling ballooneval
let g:netrw_nobeval = 1

" Enable markdown folding
let g:markdown_folding=1

" Show relative paths by default in bufexplorer
let g:bufExplorerShowRelativePath = 1

" Show no name buffers in bufexplorer, I want to be able to find them easily
" Note: BufExplorer lists quickfix and location list buffers as [No Name] if
" it finds them in the buffer list. This is confusing and makes it easy to
" break things, so I'm using the vim-qf plugin to hide them from the list.
" FIXME: this probably warrants forking and fixing BufExplorer to hide them.
let g:bufExplorerShowNoName = 1

" Disable default BufExplorer key mappings (use custom mappings)
let g:bufExplorerDisableDefaultKeyMapping = 1

" Accept/close popup/completion menu with enter/cr, ah sanity, finally
let g:lexima_accept_pum_with_enter = 1

" Disable ALE linting by default, use ALEToggle to enable
let g:ale_enabled = 0

" And stop enabling balloneval, even when linting disabled!
let g:ale_set_balloons = 0

" Even when ALE is enabled, disable automatic linting as you type
" Note: linting still runs on enter, save and leave insert mode
let g:ale_lint_on_text_changed = 'never'

" Don't highlight linting errors in source, just use sign column
let g:ale_set_highlights = 0

" Only use ALE to run linters, use coc.nvim with language servers
" Note: Coc.nvim configured to send disgnostics to ALE for display
let g:ale_disable_lsp = 1

" Disable coc.nvim service at startup, use CocStart to enable
let g:coc_start_at_startup = 0

" Don't automagically colorize text, use <leader>tc to toggle
let g:Hexokinase_ftEnabled = []

" Include triple hex when colorizing text (missing from default)
let g:Hexokinase_optInPatterns = [
  \ 'full_hex',
  \ 'triple_hex',
  \ 'rgb',
  \ 'rgba',
  \ 'hsl',
  \ 'hsla',
  \ 'colour_names'
  \ ]

" Use background to highlight colours, ugly, but clearly visible
let g:Hexokinase_highlighters = ['backgroundfull']

" Tell NERDTree to respect wildignore
let NERDTreeRespectWildIgnore = 1

" Stop NERDTree from hijacking netrw, I want to use both :-)
let NERDTreeHijackNetrw = 0

" Show hidden files in NERDTree (same as netrw)
let NERDTreeShowHidden = 1

" Custom statusline for NERDTree (just show buffer name, e.g. NERD_tree_1)
" Another option to consider is to show the currently selected file, e.g.
" https://github.com/vim-airline/vim-airline/issues/271#issuecomment-40597276
let NERDTreeStatusline = '%t'

" Minimalist NERDTree UI, no bookmarks, help hint or up a dir
let NERDTreeMinimalUI = 1

" Always show the netrw banner, so it's not mistaken for NERDTree
let g:netrw_banner = 1

" Don't go back to netrw when choosing to edit the alternate file,
" actually go back to the last edited file (same as bufexplorer)
let g:netrw_altfile = 1

" Skip editorconfig with fugitive
let g:EditorConfig_exclude_patterns = ['fugitive://.*']

" Prevent editorconfig from enabling automatic text wrapping
let g:EditorConfig_preserve_formatoptions = 1

" Disable editorconfig use of colorcolumn to highlight long lines
" See custom autocmd, which subtly highlights long lines instead
let g:EditorConfig_max_line_indicator = 'none'

" Disable editorconfig trim_trailing_whitespace, use better_whitespace
let g:EditorConfig_disable_rules = ['trim_trailing_whitespace']

" Disable whitespace highlighting by default, toggle with <leader><space>
let g:better_whitespace_enabled = 0

" Automatically strip whitespace on save using better_whitespace plugin
let g:strip_whitespace_on_save = 1

" Only strip whitespace on modified lines and don't ask for confirmation
let g:strip_only_modified_lines = 1
let g:strip_whitespace_confirm = 0

" Use editorconfig hook to automatically enable/disable whitespace stripping
function! <SID>EditorConfigHook(config)
  try
    let l:trim_trailing_whitespace = a:config->get('trim_trailing_whitespace')
    if l:trim_trailing_whitespace == 'true'
      exec 'EnableStripWhitespaceOnSave'
    elseif l:trim_trailing_whitespace == 'false'
      exec 'DisableStripWhitespaceOnSave'
    endif
  catch
    echo 'EditorConfigHook Failed: ' . v:exception
  endtry
  return 0 " Return 0 to show no error happened
endfunction
call editorconfig#AddNewHook(function('<SID>EditorConfigHook'))

" Don't autohide scratch window when leaving insert mode
let g:scratch_insert_autohide = 0

" Highlight JSX embedded in javascript files
let g:jsx_ext_required = 0

" Disable signify by default, enable as needed using gd mapping (see below)
let g:signify_disable_by_default = 1

" Disable gd mapping for GoDef command, gd = git diff, use CTRL-[ for GoDef
let g:go_def_mapping_enabled = 0

" Prefix fzf commands with FZF, e.g. Files becomes FZFFiles (avoids polluting
" top level namespace and makes it easier to find and complete FZF commands)
let g:fzf_command_prefix = 'FZF'

" Don't automatically change working directory to project root
" Just using public function FindRootDirectory() with MRU mappings
let g:rooter_manual_only = 1

" Override indent level for continuation lines in vimscript
" Default is shiftwidth() * 3, see $VIMRUNTIME/ftplugin/vim.vim
let g:vim_indent_cont = 2

if executable('glow')
  let g:markdown_preview_command = 'glow -s dark -p'
elseif executable('mdcat')
  let g:markdown_preview_command = 'mdcat -p'
else
  " FIXME should this error only appear when attempting to preview markdown???
  echoerr "WARNING: no markdown preview executable found, install glow to fix this, see https://github.com/charmbracelet/glow"
endif

if executable('rg')
  let $RIPGREP_CONFIG_PATH = expand('~/.vim/rgconfig')
  set grepprg=rg\ --vimgrep\ --smart-case\ --hidden\ --no-ignore-parent\ --ignore-file\ ~/.vim/rgignore
  set grepformat=%f:%l:%c:%m
  let $FZF_DEFAULT_COMMAND = 'rg --no-config --files --hidden --color never --ignore-file ~/.vim/rgignore'
elseif executable('ag')
  set grepprg=ag\ --vimgrep\ --hidden
  set grepformat=%f:%l:%c:%m
  let $FZF_DEFAULT_COMMAND = 'ag --literal --files-with-matches --nocolor --hidden -g ""'
else
  echoerr "WARNING: grep alternative not found, finding files will be slow, install ripgrep to fix this, see https://github.com/BurntSushi/ripgrep"
endif

" Set bat theme for fancy syntax highlighting in FZF preview window
if executable('bat')
  " GitHub theme works well with dark and light backgrounds and color schemes
  let $BAT_THEME='GitHub'
else
  echoerr "WARNING: bat executable not found, preview window will not have syntax highlighting, install bat to fix this, see https://github.com/sharkdp/bat"
endif

" FZF color scheme, see https://github.com/junegunn/fzf/wiki/Color-schemes
function! <SID>UpdateFZFColors()
  let colors_name = get(g:, 'colors_name', 'default')
  if colors_name ==# 'solarized'
    if &background ==# 'light'
      let $FZF_DEFAULT_OPTS='
        \ --color fg:240,bg:230,hl:33,fg+:241,bg+:221,hl+:33
        \ --color info:33,prompt:33,pointer:166,marker:166,spinner:33'
    else
      let $FZF_DEFAULT_OPTS='
        \ --color dark,hl:33,hl+:37,fg+:235,bg+:136,fg+:254
        \ --color info:254,prompt:37,spinner:108,pointer:235,marker:235'
    endif
  elseif ( colors_name ==# 'jellybeans' )
    let $FZF_DEFAULT_OPTS='
      \ --color fg:188,bg:233,hl:103,fg+:222,bg+:234,hl+:104
      \ --color info:183,prompt:110,spinner:107,pointer:167,marker:215'
  elseif ( colors_name ==# 'PaperColor' )
    let $FZF_DEFAULT_OPTS='
      \ --color=light,fg:#4d4d4c,bg:#eeeeee,hl:#d7005f
      \ --color=fg+:#4d4d4c,bg+:#e8e8e8,hl+:#d7005f
      \ --color=info:#4271ae,prompt:#8959a8,pointer:#d7005f
      \ --color=marker:#4271ae,spinner:#4271ae,header:#4271ae'
  else
    let $FZF_DEFAULT_OPTS='--color ' . &background
  endif
endfunction
autocmd VimEnter,ColorScheme * call <SID>UpdateFZFColors()

" Tweak some annoying highilghting from PaperColor and solarized
autocmd VimEnter,ColorScheme *
  \ if get(g:, 'colors_name', v:null) ==# 'PaperColor' |
  \   hi Spellbad guibg=NONE guifg=NONE |
  \ elseif get(g:, 'colors_name', v:null) ==# 'solarized' |
  \   hi MatchParen ctermbg=NONE guibg=NONE |
  \   hi SpecialKey cterm=NONE ctermbg=NONE ctermfg=239 gui=NONE guibg=NONE guifg=#bcbcbc |
  \ endif

" Add cut/move mappings (delete operations overridden by vim-cutlass to just
" delete, not yank and delete, see https://github.com/svermeulen/vim-cutlass)
" Warning: breaks "m{a-zA-Z}" command to set named marks, which I don't use
nnoremap m d
xnoremap m d
nnoremap mm dd
nnoremap M D

" Make Y act like D and C, i.e. yank until EOL rather than yank entire line
noremap Y y$

" And make delete key just delete, i.e. send text to blackhole register
nnoremap <Del> "_x
vnoremap <Del> "_x

" Stop recording commands and opening the command history by accident
nnoremap q <nop>

" Use q to close the quickfix window and return to the previous window
autocmd FileType qf nnoremap <silent> <buffer> q :wincmd p<CR>:cclose<CR>:wincmd =<CR>

" Fix previous window navigation when existing quickfix window re-used
autocmd QuickFixCmdPre * if &ft == 'qf' | wincmd p | end

" Retain selection after shifting highlighted lines in visual mode
vnoremap > >gv
vnoremap < <gv

" Mark previous cursor position when entering visual mode, see :h m`
nnoremap v m`v
nnoremap V m`V
nnoremap <C-v> m`<C-v>

" And return to previous cursor position when leaving visual mode
" Pattern derived from https://github.com/vim/vim/commit/25def2c8
if exists('##ModeChanged')
  autocmd ModeChanged [vV\x16]*:n exe "normal! ``"
endif

" Make backspace work with visual selections again. This used to work by
" default in version 8.1.1722, but upgrading to version 8.1.2234 broke it,
" without this mapping, backspacing in visual mode just moves the cursor.
vnoremap <BS> "_x

" Move block selections around in visual mode with schlepp plugin
vmap <C-Up> <Plug>SchleppUp
vmap <C-Down> <Plug>SchleppDown
vmap <C-Left> <Plug>SchleppLeft
vmap <C-Right> <Plug>SchleppRight

" Allow standard windows & gnome shortcuts to shift lines (for pairing)
vnoremap <Tab> >
vnoremap <S-Tab> <

" Tab navigation with Ctrl-Tab (only works in gui vim)
noremap <C-Tab> :tabnext<cr>
noremap <S-C-Tab> :tabprevious<cr>

" Open plugin defined alternate file, e.g. unit test for model
nnoremap <leader>a :A<CR>

" Open vim alternate file, i.e. previously edited file in window
nnoremap <Leader>g <C-^>

" Search with nomagic, almost like fgrep/grep --fixed-strings, see :h nomagic
nnoremap <leader>/ /\V

" Toggle ALE linting (disabled by default)
function! ALEToggle()
  if g:ale_enabled
    ALEDisable
    echohl MoreMsg | echom 'ALE disabled' | echohl None
  else
    ALEEnable
    echohl MoreMsg | echom 'ALE enabled' | echohl None
  endif
endfunction
nnoremap <Leader>ta :call ALEToggle()<CR>

" Toggle coc.nvim service (disabled by default)
function! CocToggle()
  if coc#rpc#ready()
    echohl MoreMsg | echom 'stopping coc.nvim service' | echohl None
    call coc#rpc#stop()
  else
    echohl MoreMsg | echom 'starting coc.nvim service' | echohl None
    call coc#rpc#start_server()
  endif
endfunction
nnoremap <leader>tc :call CocToggle()<CR>

" Toggle quickfix list
function! QuickfixListToggle()
  if get(getqflist({'winid': 1}), 'winid') != 0
    cclose
  elseif getqflist() != []
    copen
  else
    echohl ErrorMsg
    echo "Quickfix List is empty."
    echohl None
  endif
endfunction
nnoremap <leader>q :call QuickfixListToggle()<CR>

" Toggle location list
function! LocationListToggle()
  if get(getloclist(winnr(), {'winid': 1}), 'winid') != 0
    lclose
  elseif getloclist(winnr()) != []
    lopen
  else
    echohl ErrorMsg
    echo "Location List is empty."
    echohl None
  endif
endfunction
nnoremap <leader>l :call LocationListToggle()<CR>

" Use K to show documentation in preview window.
function! ShowDocumentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  elseif (coc#rpc#ready())
    call CocActionAsync('doHover')
  else
    execute '!' . &keywordprg . " " . expand('<cword>')
  endif
endfunction
nnoremap <silent> K :call ShowDocumentation()<CR>

" Stupid simple tab completion, file path and keyword completion only
" Cribbed from Gary Bernhardt's vimrc and Akshay Hegde's VimCompletesMe
" For more elaborate completions, see :h 'ins-completion' or use coc.nvim
function! <SID>SimpleTab()
  let pos = getpos('.')
  let substr = matchstr(strpart(getline(pos[1]), 0, pos[2]-1), "[^ \t]*$")
  if empty(substr)
    return "\<tab>"
  elseif match(substr, '\/') != -1
    return "\<c-x>\<c-f>"
  else
    return "\<c-n>"
  endif
endfunction
inoremap <expr> <tab> <SID>SimpleTab()

" Window mappings
" switch to window pseudo-mode (uses window mode plugin, no more keyboard
" contortions - window mode automatically prefixes <C-w> to all keypresses)
nnoremap <leader>wm :WindowMode<CR>
" open vim defined alternate file in new vertial split
nnoremap <leader>wg :vs#<CR>
" open plugin defined alternate file in new vertial split
nnoremap <leader>wa :AV<CR>
" shortcuts for opening new splits
nnoremap <leader>ws :wincmd s<CR>
nnoremap <leader>wv :wincmd v<CR>
" rotate and exchange windows
nnoremap <leader>wr :wincmd r<CR>
nnoremap <leader>wx :wincmd x<CR>
" move horizonal split to vertical
nnoremap <leader>wl :wincmd L<CR>
" navigation with arrow keys
nnoremap <C-Up> :wincmd k<CR>
nnoremap <C-Down> :wincmd j<CR>
nnoremap <C-Left> :wincmd h<CR>
nnoremap <C-Right> :wincmd l<CR>
" resize all windows equally
nnoremap <leader>= :wincmd =<CR>
" increase/decrease window width
nnoremap > :wincmd ><CR>
nnoremap < :wincmd <<CR>

" indentation text objects, visual, select, and operator-pending modes
let g:vindent_object_XX_ii = 'ii' " inner indent level, including blank lines
let g:vindent_object_OX_ii = 'iI' " inner indent level, excluding blank lines
let g:vindent_object_XX_ai = 'ai' " an indent level and the line above
let g:vindent_object_XX_aI = 'aI' " an indent level and the lines above/below

" Experimental: indentation motions, nmap only to avoid breaking {Visual}=,
" does still break ={motion}, but I never use ={motion}, that's scary shit.
" go to next line at the same indent
nmap <silent> = <Plug>(VindentBlockMotion_OO_next)
" go to previous line of same indent
nmap <silent> g= <Plug>(VindentBlockMotion_OO_prev)
" go to prev line with different indent
nmap <silent> [= <Plug>(VindentMotion_prev_diff)
" go to next line with different indent
nmap <silent> ]= <Plug>(VindentMotion_next_diff)

" Tag navigation
" remap CTRL-] to show list when multiple matches (use tjump)
nnoremap <C-]> g<C-]>
" use CTRL-\ to jump to definition in next available window
function! JumpToTagInSplit()
  let currword = expand("<cword>")
  let startwin = winnr()
  " Move to next window with a normal buffer
  let c = 0
  let n = winnr('$')
  while c < n
    exec 'wincmd w'
    if empty(getbufvar(+expand("<abuf>"), "&buftype"))
      break
    endif
    let c = c + 1
  endwhile
  " Back where we started? Open a new split
  if winnr() == startwin
    exec 'wincmd v'
  endif
  try
    exec "tjump ".currword
  catch
    " Go back to startwin on error
    exec startwin . "wincmd w"
    echoerr v:exception
  endtry
endfunction
nnoremap <C-\> :call JumpToTagInSplit()<CR>

" Toggle project drawer / tree view
" FIXME: update to use NERDTreeFind if buffer has file
nnoremap <leader>d :NERDTreeToggle<CR>

" Show/hide diff/changes in sign column
nnoremap <leader>td :SignifyToggle<CR>

" Toggle file explorer (Netrw)
function! NetrwToggle()
  if &ft == 'netrw'
    Rexplore
  else
    Explore
  end
endfunction
nnoremap <Leader>e :call NetrwToggle()<CR>

" I think I needed to set this for VimspectorInstall to work properly
" FIXME: investigate why this was necessary, docs suggest it should not be
let g:vimspector_base_dir = expand('~/.vim/bundle/vimspector')

" Launch graphical debugger/inspector (vimspector)
nmap <Leader>i <Plug>VimspectorLaunch

" Stop FZF opening files in nofile and quickfix windows, with some exceptions
let g:fzf_reuse_windows = ['bufexplorer', 'mru']
function! FZFOpen(cmd)
  let c = 0
  let wincount = winnr('$')
  while ( !empty(&buftype) && index(g:fzf_reuse_windows, &ft) == -1 && c < wincount )
    wincmd w
    let c = c + 1
  endwhile
  exec g:fzf_command_prefix . a:cmd
endfunc

" Fuzzy find files
nnoremap <leader>ff :call FZFOpen('Files')<CR>

" Fuzzy find buffers
nnoremap <leader>fb :call FZFOpen('Buffers')<CR>

" Fuzzy find commits
nnoremap <leader>fc :call FZFOpen('Commits')<CR>

" Fuzzy find commands (things to "execute")
nnoremap <leader>fe :call FZFOpen('Commands')<CR>

" Fuzzy find git ls-files
nnoremap <leader>fg :call FZFOpen('GitFiles')<CR>

" Fuzzy find help tags
nnoremap <leader>fh :call FZFOpen('Helptags')<CR>

" Fuzzy find most recently used files within project root directory
" Note: relies on MRU plugin, use <leader>fm to fzf find all MRU files
command! FZFRecent :call fzf#run(fzf#wrap({'source': MruGetFiles(FindRootDirectory()), 'sink': 'e'}))
nnoremap <leader>fr :call FZFOpen('Recent')<CR>

" Fuzzy find most recently used files
nnoremap <leader>fm :call FZFOpen('Mru')<CR>

" Fuzzy find tags
nnoremap <leader>ft :call FZFOpen('Tags')<CR>

" Custom grep prompt, inspired by vim-grepper, but simpler, just runs grepprg
" silently to avoid the "Press ENTER to continue" prompt after running external
" commands and escapes cmdline special chars to avoid expansion of # and friends
function! GrepPrompt(...)
  let inputstr = trim(input('grep> ', (a:0 > 0 ? a:1 : ''), 'customlist,GrepComplete'))
  if empty(inputstr) | redraw! | return | end
  try
    exec 'silent grep! '. escape(inputstr, '#%')
  catch /E40:/ " shell error, re-run unsilent to see error output
    try
      exec 'unsilent grep! '. escape(inputstr, '#%')
    catch /E40:/
      call setqflist([], 'r', {'title': &grepprg . ' ' . inputstr, 'items': []})
    endtry
  endtry
  redraw! | copen
endfunction

" Simple completion for grep prompt, also inspired by vim-grepper
function! GrepComplete(lead, _line, _pos)
  let args = split(a:lead, '.*\s\zs', 1)
  if len(args) < 2 | return [] | end
  let path = args[-1]
  let head = join(args[0:-2])
  return map(getcompletion(args[-1], 'file'), 'head . fnameescape(v:val)')
endfun

" Search in files using grep program, see :help grepprg and :help grep
nnoremap <leader>s :call GrepPrompt()<CR>

" Search in files for word or WORD under cursor
nnoremap <leader>y :call GrepPrompt(expand('<cword>'))<CR>
" Note: shell escape WORD to prevent expansion
nnoremap <leader>Y :call GrepPrompt(shellescape(expand('<cWORD>')))<CR>

" List projects, only used in GUI vim, see gvimrc
if has('gui_running')
  nnoremap <leader>p :SessionSave<CR>:SessionList<CR>
endif

" List open files/buffers
nnoremap <leader>b :ToggleBufExplorer<CR>

" List most recently used files
nnoremap <leader>m :MRUToggle<CR>

" List most recently used files within project root directory
nnoremap <leader>r :exec ':MRU ' . FindRootDirectory()<CR>

" Outline view of current file
nnoremap <leader>o :TagbarToggle<CR>

" Zoom in/out current window
function! ZoomWinChanged(state) abort
  if a:state
    let g:ZoomWin_statusline = '[ZoomWin]'
  else
    let g:ZoomWin_statusline = ''
  endif
endfunction
let g:ZoomWin_funcref= function('ZoomWinChanged')
nnoremap <leader>z :ZoomWin<CR>

" Expand/maximize current window
" See https://stackoverflow.com/a/26551079/17278003
function! ExpandWin() abort
  if winnr('$') == 1 | return | endif
  if exists('w:expanded') && w:expanded
    execute w:expand_winrestcmd
    let w:expanded = 0
  else
    let w:expand_winrestcmd = winrestcmd()
    resize
    vertical resize
    let w:expanded = 1
  endif
endfunction
autocmd WinLeave * if exists('w:expanded') && w:expanded | call ExpandWin() | endif
nnoremap <Leader>x :call ExpandWin()<CR>

" Highlight whitespace
nnoremap <leader><space> :ToggleWhitespace<CR>

" Toggle spell checking
nnoremap <Leader>ts :setlocal spell!<CR>

" Toggle list mode (show whitespace)
nnoremap <Leader>tw :setlocal list!<CR>

" Toggle colorizing of color codes and names
" Note: Hexokinase requires termguicolors
nnoremap <leader>th :set termguicolors!<CR>:HexokinaseToggle<CR>

" Toggle indent guides / lines
nnoremap <leader>ti :IndentLinesToggle<CR>

" Some extra mappings for convenience/speed
" Single key to toggle bufexplorer, I use this all the time
nnoremap ; :ToggleBufExplorer<CR>

" Remap gs to open Scratch window in normal rather than insert mode
let g:scratch_no_mappings = 1 " must disable plugin mappings first
nnoremap gs :Scratch<CR>

" Remove current search highlighting when redrawing screen
nnoremap <C-L> :nohl<CR>:redraw!<CR>

if has("clipboard")
  " copy to and paste from system clipboard
  set clipboard=unnamed

  if has("unnamedplus")
    " and to X11 primary selection if available
    set clipboard+=unnamedplus
  endif

  " Allow basic windows/gnome/kde editing shortcuts. Copied from mswin.vim to
  " help with pairing, but implements fewer shortcuts, and in fewer modes, so
  " this doesn't break things like the CTRL-V mapping for visual block mode.

  " CTRL-X and SHIFT-Del are Cut in visual mode
  vnoremap <C-X> "+x
  vnoremap <S-Del> "+x
  " CTRL-C and CTRL-Insert are Copy in visual mode
  vnoremap <C-C> "+y
  vnoremap <C-Insert> "+y
  " CTRL-V and SHIFT-Insert are Paste in insert and visual modes
  exe 'inoremap <script> <C-V>' paste#paste_cmd['i']
  exe 'vnoremap <script> <C-V>' paste#paste_cmd['v']
  inoremap <S-Insert> <C-V>
  vnoremap <S-Insert> <C-V>
  " CTRL-Z is Undo in normal and insert modes
  noremap <C-Z> u
  inoremap <C-Z> <C-O>u
  " CTRL-Y is Redo in normal and insert modes
  noremap <C-Y> <C-R>
  inoremap <C-Y> <C-O><C-R>
  " CTRL-A is Select All in normal, insert and visual modes
  noremap <C-A> gggH<C-O>G
  inoremap <C-A> <C-O>gg<C-O>gH<C-O>G
  vnoremap <C-A> <C-C>ggVG

  " CTRL-V and SHIFT-insert are also Paste in terminal job mode
  tnoremap <C-V> <C-W>"+
  tnoremap <S-Insert> <C-W>"+
endif

" Make p paste from unanmed register in terminal normal mode
au TerminalWinOpen *
  \ nnoremap <silent> <buffer> p :call term_sendkeys('', getreg()) \| normal! A<CR>

if has('mouse')
  " enable mouse support in normal, visual and insert modes
  set mouse=nvi
endif

" Default format options, auto-format comments, but not code/text
set formatoptions=croql

" Custom filetype detection, runs after built in filetype detection
" Using augroup filetypedetect means this re-runs on :filetype detect,
" which means it works after restoring a macvim session (see gvimrc).
augroup filetypedetect
  " Additional ruby syntax highlighting
  autocmd BufRead,BufNewFile {Berksfile,Capfile,Vagrantfile,Thorfile,pryrc,.pryrc,*.cap}
    \ setfiletype ruby |

  " Set cloudformation filetypes to enable linting in ALE
  autocmd Filetype yaml,json
    \ if search('AWSTemplateFormatVersion', 'nwc') |
    \   let &ft=&ft . '.cloudformation' |
    \ endif

  " Set conf.local filetype to conf
  autocmd BufRead,BufNewFile *.conf.local setfiletype conf

  " Crude autodetection of some common rc and other dotfile types/formats
  autocmd BufRead,BufWrite .*rc,$HOME/.*
    \ if empty(&ft) |
    \   if getline(1) =~ '^{' |
    \     setfiletype json |
    \   elseif getline(1) == '---' |
    \     setfiletype yaml |
    \   elseif getline(1) =~ '^\w\+:' && ( getline(2) =~ '^\w\+:' || getline(2) =~ '^\s\+\-\s\+\w\+' ) |
    \     setfiletype yaml |
    \   elseif search('^\[.*\]', 'nw') && search('^\w\+\s*=\s*\(\w\|\"\)', 'nwc') |
    \     setfiletype dosini |
    \   endif |
    \ endif

  " Even cruder autodetection of text files with no file extension
  autocmd BufRead,BufWrite *
    \ if empty(&ft) && empty(expand('%:e')) && search('\c^\w\+', 'nwc', 10) |
    \   setfiletype text |
    \ endif
augroup END

" Turn on spell checking by default for git commits
autocmd FileType gitcommit setlocal spell

" Enable syntax highlighting for long lines in git commits
autocmd FileType gitcommit setlocal synmaxcol=0

" Automatically wrap markdown text at textwidth
autocmd FileType markdown setlocal formatoptions+=t

" Mapping to load markdown preview in popup window
autocmd FileType markdown
  \ nnoremap <buffer> <leader>v :silent execute 'FloatermNew --disposable --title='. expand('%:~:.') . ' ' . g:markdown_preview_command . ' %'<CR>

" Turn on spell checking by default for markdown files
autocmd FileType markdown setlocal spell

" Use html omnicompletion for xhtml documents
autocmd FileType xhtml set omnifunc=htmlcomplete#CompleteTags

" Use xmllint as exernal program for formatting xml
autocmd FileType xml setlocal formatprg=xmllint\ --format\ --recover\ -\ 2>/dev/null

" Use jsonlint as external program for formatting json
autocmd FileType json setlocal formatprg=jsonlint\ --pretty-print\ 2>/dev/null

" Use black as external program for formatting python
autocmd FileType python setlocal formatprg=black\ --quiet\ -\ 2>/dev/null

" Avoid error editing crontab: temp file must be edited in place
autocmd filetype crontab setlocal nobackup nowritebackup

" Use syntax based completion when no omnicompletion available
if exists("+omnifunc")
  autocmd Filetype *
    \	if &omnifunc == "" |
    \	  setlocal omnifunc=syntaxcomplete#Complete |
    \	endif
endif

" autochdir when in insert mode for relative file path completion
" stolen from, damn I forget where, but I definitely stole it
" FIXME: remap i_CTRL-X_CTRL-F and use au CompleteDone instead?
augroup working_directory
  autocmd!
  " set current directory on insert mode
  autocmd InsertEnter * let w:save_cwd = getcwd() | silent! lcd %:p:h
  " switch back to previous directory when leaving insert mode
  autocmd InsertLeave * if exists('w:save_cwd') | silent execute 'lcd' fnameescape(w:save_cwd) | endif
  " catch edge cases when leaving window or vim while in insert mode
  autocmd WinLeave * if exists('w:save_cwd') | silent execute 'lcd' fnameescape(w:save_cwd) | endif
  autocmd VimLeavePre * windo if exists('w:save_cwd') | silent execute 'lcd' fnameescape(w:save_cwd) | endif
augroup END

" Subtly highlight long lines rather than display colorcolumn
function! <SID>HighlightLongLines()
  for l:match in getmatches()
    if get(l:match, 'group', '') == 'ColorColumn'
      call matchdelete(get(l:match, 'id'))
    endif
  endfor
  if &textwidth > 0
    call matchadd('ColorColumn', '\%'.(&tw+1).'v.\+', -1)
  endif
endfunction
" Apply long line highlighting whenever textwidth option is set
autocmd OptionSet textwidth call <SID>HighlightLongLines()
" And on VimEnter because OptionSet autocmds do not run on startup
autocmd VimEnter * bufdo call <SID>HighlightLongLines()

" Experimental: Only show cursorline in currently focused/active window
" Note: Both Buf{Enter,Leave} and Win{Enter,Leave} required to handle
" various edge cases with popups, same buffer in multiple windows etc.
autocmd WinEnter,BufEnter * setlocal cursorline
autocmd WinLeave,BufLeave * setlocal nocursorline

" Jump to last known cursor position when editing (except for git commits)
autocmd BufReadPost *
  \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft != 'gitcommit' |
  \   exe "normal! g`\"" |
  \ endif

" Diff a buffer with the file from which it was originally loaded
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
    \ | wincmd p | diffthis
endif

" Set working directory when opening vim to edit a particular file
function! <SID>SetWorkingDir()
  if argc() != 0
    if isdirectory(argv(0))
      exec 'cd' argv(0)
    elseif filereadable(argv(0))
      exec 'cd %:p:h'
    end
  endif
endfunction
autocmd VimEnter * call <SID>SetWorkingDir()

" Experimental: do the right thing with swap files, inspired by vim-autoswap
function! <SID>HandleSwapfile(filename, swapname)
  if getftime(a:swapname) < getftime(a:filename)
    " swapfile is older than file itself, just delete it
    let v:swapchoice = 'd'
  elseif executable('lsof')
    call system('lsof ' . a:swapname)
    if v:shell_error == 0
      " swapfile owned by another vim process, open readonly
      let v:swapchoice = 'o'
    else
      " swapfile seems to be the result of a crash, recover
      let v:swapchoice = 'r'
    endif
  endif
endfunction
autocmd SwapExists * call <SID>HandleSwapfile(expand('<afile>:p'), v:swapname)

" Show diff from git commit --verbose in a new vertical split
" Inspired by https://github.com/rhysd/committia.vim, but mostly copied
" from https://gist.github.com/aroben/d54d002269d9c39f0d5c89d910f7307e
autocmd VimEnter COMMIT_EDITMSG call <SID>GitCommitSplitDiff()
autocmd QuitPre COMMIT_EDITMSG windo if &ft == 'diff' | bwipeout | endif
function <SID>GitCommitSplitDiff()
  " Save the contents of the z register
  let old_z = getreg("z")
  let old_z_type = getregtype("z")

  try
    call cursor(1, 0)
    let diff_start = search("^diff --git")
    if diff_start > 0
      " Move diff from commit message to the z register
      :silent .,$delete z
      :silent write
      call cursor(1, 0)
      " Paste from z register into a new vertial split
      vnew
      silent normal! V"zP
      " Configure the diff buffer
      setlocal filetype=diff buftype=nofile readonly nonumber noswapfile nomodified nomodifiable nofoldenable
      silent file COMMIT_DIFF
      " Get back to the commit message
      wincmd p
    endif
  finally
    " Restore the z register
    call setreg("z", old_z, old_z_type)
  endtry
endfunction
