#!/bin/bash

export EDITOR=vim

# Set TERM to something suitable for local and remote systems
# Note: SSH client always sends the TERM env var to the server
export TERM='xterm-color'

# solarized dark colours for BSD ls command
export CLICOLOR=1
export LSCOLORS=exfxfeaeBxxehehbadacea

# solarized dark colours for GNU ls & readline colored-stats
if which gdircolors &> /dev/null; then
  eval `gdircolors ~/dotfiles/bash/dircolors-solarized.ansi-dark`
fi

# Copy path before munging so we can restore it when reloading the shell
export ORIGINAL_PATH=$PATH

# Set the node path to allow use of globally installed modules
export NODE_PATH=/usr/local/lib/node_modules

# Cucumber comments are grey by default, hard to see using solarized dark
export CUCUMBER_COLORS=comment=cyan

export GREP_OPTIONS='--color=auto --exclude=tags --exclude-dir=.git'

# Spring is a PITA for anything other than simple development workflows
# Use spring command to explicitly use as required (see aliases below)
export DISABLE_SPRING=1

# Stop homebrew from auto-updating, which can cause all sorts of mayhem
export HOMEBREW_NO_AUTO_UPDATE=1

alias which="/usr/bin/which" # fuck you node-which

# check if homebrew is installed and update path such that
# homebrew binaries take precedence over system binaries
if which brew &> /dev/null; then
  has_brew=true
  brew_prefix=`brew --prefix`
  export PATH=$brew_prefix/bin:$brew_prefix/sbin:$PATH
fi

# add /usr/local/sbin to path if necessary
if ! echo $PATH | grep /usr/local/sbin &> /dev/null; then
  export PATH=$PATH:/usr/local/sbin
fi

export PATH=$HOME/bin:$PATH

# add nodenv shims to path and enable nodenv autocompletion
if which nodenv &> /dev/null; then eval "$(nodenv init --no-rehash -)"; fi

# add rbenv shims to path and enable rbenv autocompletion
if which rbenv &> /dev/null; then eval "$(rbenv init --no-rehash -)"; fi

# add bundler binstubs to path (see ~/dotfiles/ruby/bundler)
export PATH="./.bundle/bin:$PATH"

# add npm binstubs to path (not sure about this, there is a node-which afer all)
export PATH="./node_modules/.bin:$PATH"

# add project specific binaries to path (e.g. rails binstubs)
export PATH="./bin:$PATH"

# Stop once env vars set if stdout not a terminal or shell not bash
# Allows file be sourced from files other than .bash_profile, without
# causing problems when sudo is configured to keep HOME env variable
# and/or target user's shell is bourne compatible, but not bash
# FIXME: clean up this garbage, use .profile and .bash_profile (is this
# even necessary anymore? I think this is from my old ubuntu/dash days)
if [ ! -t 1 ] || [ $(basename $SHELL) != 'bash' ]; then
  return
fi

if [ ${BASH_VERSINFO[0]} -lt 4 ]; then
  echo Warning: old bash version detected, $BASH_VERSION, some things might not work >&2
  if $has_brew; then
    echo "Use homebrew installed bash as your login shell to fix this:" >&2
    echo "    brew install bash" >&2
    echo "    sudo sh -c \"echo $brew_prefix/bin/bash >> /etc/shells\"" >&2
    echo "    chsh -s $brew_prefix/bin/bash" >&2
  fi
fi

# Hack cd to automatically push to the directory stack, but avoid duplicates
# Similar to zsh with setopt autopushd pushdignoredups pushdsilent pushdtohome
function cd() {
  builtin pushd -n "$PWD" > /dev/null
  builtin cd "$@" # do not return on fail, we've already pushed to the stack
  lastpos=$( builtin dirs -l -v | grep -E "${PWD}$" | tail -n 1 | awk '{print $1}' )
  if [ "$lastpos" -gt 0 ]; then
    builtin popd "+${lastpos}" > /dev/null || return
  fi
}

# Select a directory from the stack and switch to it
function d() {
  old_columns=$COLUMNS
  COLUMNS=10; select dir in $(builtin dirs -l -p | head -n10); do cd "$dir" || break; break; done
  COLUMNS=$old_columns
}

# bash completion
if [ $has_brew ] && [ -r $brew_prefix/etc/profile.d/bash_completion.sh ]; then
  source $brew_prefix/etc/profile.d/bash_completion.sh
  if [ -z $BASH_COMPLETION_COMPAT_DIR ]; then
    export BASH_COMPLETION_COMPAT_DIR=/usr/local/etc/bash_completion.d
  fi
fi

# git completion
if ! type __git_ps1 &> /dev/null; then
  source ~/dotfiles/bash/git-prompt.sh
  source ~/dotfiles/bash/git-completion.bash
fi

# capistrano command completion
source ~/dotfiles/bash/capistrano.bash

# knife solo command completion
source ~/dotfiles/bash/knife-solo-completion.bash

# git prompt for local workstation
if [ -z "$SSH_CLIENT" ]; then
  GIT_PS1_SHOWDIRTYSTATE=1
  PS1='\w$(__git_ps1 "[%s]")\$ '
fi

# if some kind of xterm, use prompt command to set window title
if [ "${TERM%%-*}" == xterm ]; then
  PROMPT_COMMAND='echo -ne "\033]0;${PWD/#$HOME/~}\007"'
fi

# Allow CTRL-s to be used to search history forward
# Disables CTRL-s mapping to stop terminal output (not needed)
stty -ixon

# quick hack to create aliases for starting and stopping postgres
if [ $has_brew ] && [ -r $brew_prefix/var/postgres ]; then
  alias pg_start="pg_ctl -D $brew_prefix/var/postgres -l $brew_prefix/var/postgres/server.log start"
  alias pg_stop="pg_ctl -D $brew_prefix/var/postgres stop -s -m fast"
fi

# reload bash shell (I always forget how)
alias reload="export PATH=$ORIGINAL_PATH; exec bash -l"

# highlight error output from git commands in red
# - highlights based on pattern match as stderr not only used for errors
# - only modifies output when both stderr and stdout are terminals
# - uses script command to ensure git sees output streams as terminals
# - only modifies output for whitelisted commands to avoid pager issues
# - doesn't work with git alises for whitelisted commands (this sucks)
# - currently relies on BSD sed, so only used with MacOS (also sucks)
if test $(uname) == Darwin; then
  git_err_red() {
    if test -t 1 && test -t 2 && [[ "$@" =~ (push|pull|clone|fetch|po|toggle) ]]; then
      script -q /dev/null ${1+"$@"} | sed -l -E $'s/^(fatal|error).*/\e[31m&\e[m/'
    else
      "$@"
    fi
  }
  alias git="git_err_red git"
fi

# use gnome-open rather than openvt
if which gnome-open &> /dev/null; then
  alias open="gnome-open"
fi

# because I keep forgetting how to do it in Linux
if ! which pbcopy &> /dev/null && which xclip &> /dev/null; then
  alias pbcopy="xclip -selection clipboard"
  alias pbpaste="xclip -o -selection clipboard"
fi

alias p='ping www.google.com'

alias v='vim'
alias vi='vim'

alias h='history'
alias hs='history'

alias b='bundle'
alias bi='bundle install'
alias be='bundle exec'

alias c='bundle exec cucumber -r features'
alias cw='bundle exec cucumber -r features -p wip'
alias cq='bundle exec cucumber -r features --tags ~@javascript --tags ~@slow'
alias cj='bundle exec cucumber -r features --tags @javascript'
alias r='bundle exec rspec spec'
alias rw='bundle exec rspec spec --tag wip'
alias rf='bundle exec rspec spec --only-failures'

alias sc='spring cucumber -r features'
alias scw='spring cucumber -r features -p wip'
alias scq='spring cucumber -r features --tags ~@javascript --tags ~@slow'
alias scj='spring cucumber -r features --tags @javascript'
alias sr='spring rspec spec'
alias srw='spring rspec spec --tag wip'
alias srf='spring rspec spec --only-failures'

alias t='tig'
complete -o default -o nospace -F _tig t

alias g='git'
complete -o default -o nospace -F _git g

alias ga='git add'
alias gd='git diff'
alias gf='git fetch'
alias gl='git log --decorate --stat'
alias gp='git peek' # peek at the last commit, see git config
alias gs='git status' # takes precedence over ghostscript in path
alias gt='git toggle' # switch to previous branch, see git config
alias gc-='git checkout -'
alias gca='git commit -v -a'
alias gco='git checkout'
alias gcb='git checkout -b'
alias gcv='git commit -v'
alias gdc='git diff --cached'
alias gpo='git po' # push current branch to origin, see git config
alias gpr='git pr' # pull from origin with rebase, see git config
alias gpt='git push --tags'
alias grd='git rd' # remove deleted files, see git config
alias gsl='git select'

__git_complete ga _git_add
__git_complete gd _git_diff
__git_complete gf _git_fetch
__git_complete gl _git_log
__git_complete gs _git_status
__git_complete gca _git_commit
__git_complete gco _git_checkout
__git_complete gcb _git_checkout
__git_complete gcv _git_commit
__git_complete gdc _git_diff

# Fudge bash completion for complex git aliases which run external commands
# See https://coderwall.com/p/d2w7oa/auto-completion-within-complex-git-alias
_git_rs() { _git_reset ; }
_git_rss() { _git_reset ; }
_git_rsh() { _git_reset ; }

if [ -f /usr/local/bin/ctags ]; then
  alias ctags='/usr/local/bin/ctags'
fi

# alias for thefuck, https://github.com/nvbn/thefuck
alias fuck='eval $(thefuck $(fc -ln -1)); history -r'

# Make random password containing letters, digits and an underscore somewhere
# The resulting password is a vim/regex word, so it's easy to copy and paste
mkpw() {
  reqlength=${1:-20}
  randomstr=`head /dev/urandom | uuencode -m - | sed -n 2p | tr -d '/+' | cut -c1-${reqlength} | tr -d '\n';`
  if ! echo $randomstr | egrep '\d' >/dev/null; then
    randomstr=`echo $(( RANDOM % 10 ))$randomstr | cut -c1-${reqlength}`
  fi
  punctchar="_"
  insertpos=`awk -v min=1 -v max=$reqlength 'BEGIN{srand(); print int(min+rand()*(max-min+1))}'`
  echo $randomstr | sed s/./\\$punctchar/$insertpos | tr -d '\n' ; if [ -t 1 ] ; then echo; fi
}

# what is my ip again?
whatismyip() { curl -s http://ipv4.icanhazip.com/ | tr -d '\n' ; if [ -t 1 ] ; then echo; fi }
